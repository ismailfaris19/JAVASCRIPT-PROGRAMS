~ Js created in just 10 days.

~ DOM: Tree of nodes/elements created by the browser.

~ NodeJS is server side run-time.

~ ExpressJS is framework for developing web applications.

~ PUT is a method of modifying resource where the client sends data that updates the entire resource if it exists or creates new if it does not exist. 

~ PATCH is a method of modifying resources where the client sends partial data that is to be updated without modifying the entire data.

~ Primitives: When you access a primitive type you work directly on its value.

# string, number, boolean, null, undefined, symbol, bigint.

~ Complex: When you access a complex type you work on a reference to its value.

# object, array, function.

~ object and map do not allow duplicates.

~ Use const for all of your references; avoid using var.

~ If you must reassign references, use let instead of var. 

~ both let and const are block-scoped, whereas var is function-scoped.

# {
    let a = 1;
    const b = 1;
    var c = 1;
  }
  console.log(a); // ReferenceError
  console.log(b); // ReferenceError
  console.log(c); // Prints 1

~ Use the literal syntax for object creation.

# const item = {};

~ Use computed property names when creating objects with dynamic property names.

# function getKey(k) {
  return `a key named ${k}`;
  }

  // good
    const obj = {
      id: 5,
      name: 'San Francisco',
      [getKey('enabled')]: true,
    };

~ Use object method shorthand.

# // good
    const atom = {
    value: 1,

    addValue(value) {
      return atom.value + value;
     },
    };

~ Use property value shorthand.

# const lukeSkywalker = 'Luke Skywalker';
  // good
    const obj = {
      lukeSkywalker,
    };

~ Group your shorthand properties at the beginning of your object declaration.

# const anakinSkywalker = 'Anakin Skywalker';
  const lukeSkywalker = 'Luke Skywalker';
  // good
    const obj = {
      lukeSkywalker,
      anakinSkywalker,
      episodeOne: 1,
      twoJediWalkIntoACantina: 2,
      episodeThree: 3,
      mayTheFourth: 4,
    };

~ Only quote properties that are invalid identifiers.

# // good
    const good = {
      foo: 3,
      bar: 4,
      'data-blah': 5,
    };

~ Do not call Object.prototype methods directly, such as hasOwnProperty, propertyIsEnumerable, and isPrototypeOf.

# // bad
    console.log(object.hasOwnProperty(key));

  // good
    console.log(Object.prototype.hasOwnProperty.call(object, key));

  // best
    const has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope.
    console.log(has.call(object, key));

                    /* or */

    import has from 'has'; // https://www.npmjs.com/package/has
    console.log(has(object, key));

~ Prefer the object spread syntax over Object.assign to shallow-copy objects. Use the object rest parameter syntax to get a new object with certain properties omitted.

~ Use the literal syntax for array creation.

# const items = [];

~ Use Array#push instead of direct assignment to add items to an array.

~ Use array spreads ... to copy arrays.

# const itemsCopy = [...items];

~ To convert an iterable object to an array, use spreads ... instead of Array.from.

# // good
    const nodes = Array.from(foo);

  // best
    const nodes = [...foo];

~ Use single quotes '' for strings.

# // good
  const name = 'Capt. Janeway';

~ Use named function expressions instead of function declarations.

~ Never declare a function in a non-function block (if, while, etc). Assign the function to a variable instead. Browsers will allow you to do it, but they all interpret it differently, which is bad news bears.

~ Always put default parameters last.

# function handleThings(name, opts = {}) { }

~ Never use the Function constructor to create a new function.

~ Spacing in a function signature.

# // bad
    const f = function(){};
    const g = function (){};
    const h = function() {};

  // good
    const x = function () {};
    const y = function a() {};

~ Class methods should use this or be made into a static method unless an external library or framework requires using specific non-static methods. Being an instance method should indicate that it behaves differently based on properties of the receiver.

# // good - this is used
    class Foo {
      bar() {
        console.log(this.bar);
      }
    }
  
  // good - constructor is exempt
    class Foo {
      constructor() {
         // ...
      }
    }
  
  // good - static methods aren't expected to use this
    class Foo {
      static bar() {
        console.log('bar');
      }
    }

~ All JavaScript objects inherit properties and methods from a prototype:
    Date objects inherit from Date.prototype
    Array objects inherit from Array.prototype
    Person objects inherit from Person.prototype

~ The Object.prototype is on the top of the prototype inheritance chain:
    Date objects, Array objects, and Person objects inherit from Object.prototype.

~ Only import from a path in one place.

# import foo, { named1, named2 } from 'foo';

~ Do not export mutable bindings.

# // bad
    let foo = 3;
    export { foo };

  // good
    const foo = 3;
    export { foo };

~ In modules with a single export, prefer default export over named export.

~ Put all imports above non-import statements.

~ Multiline imports should be indented just like multiline array and object literals.

# // good
    import {
      longNameA,
      longNameB,
      longNameC,
      longNameD,
      longNameE,
    } from 'path';

~ Disallow Webpack loader syntax in module import statements.

# import fooSass from 'foo.scss';

~ Do not include JavaScript filename extensions.

~ Don’t use iterators. Prefer JavaScript’s higher-order functions instead of loops like for-in or for-of.

~ To create a generator, we need a special syntax construct: function*, so-called “generator function”.

~ "generator function" creates "generator object".

~ The main method of a generator is next(). The result of next() is always an object with two properties: {value: 1, done: false}

~ The actions are FIXME: -- need to figure this out or TODO: -- need to implement.

# // FIXME: shouldn’t use a global here
    total = 0;

  // TODO: total should be configurable by an options param
    this.total = 0;

~ A base filename should exactly match the name of its default export.

~ Acronyms and initialisms should always be all uppercased, or all lowercased.

~ Do not use JavaScript getters/setters as they cause unexpected side effects and are harder to test, maintain, and reason about.

# // bad
    class Dragon {
      get age() {
        // ...
      }

      set age(value) {
        // ...
      }
    }

  // good
    class Dragon {
      getAge() {
        // ...
      }

      setAge(value) {
        // ...
      }
    }

~ For DOM queries use Cascading $('.sidebar ul') or parent > child $('.sidebar > ul').

# // good
    $('.sidebar ul').hide();

  // good
    $('.sidebar > ul').hide();

  // good
    $sidebar.find('ul').hide();

~ When you pass a function as an argument, remember not to use parenthesis.

~ producing code : some code that loads the data over a network. Eg: “singer”.

~ consuming code : wants the result of the “producing code” once it’s ready. Many functions may need that result. Eg: “fans”.

~ The function passed to new Promise is called the executor. When new Promise is created, the executor runs automatically. A Promise is a JavaScript object that links producing code and consuming code.

# let promise = new Promise(function(resolve, reject) {
    // executor (the producing code, "singer")
  });

~ Its arguments resolve and reject are callbacks provided by JavaScript itself. Our code is only inside the executor.

~ resolve(value) : if the job is finished successfully, with result value.

~ reject(error) : if an error has occurred, error is the error object.

~ The Promise object supports two properties: state and result.

~ Consuming functions can be registered (subscribed) using methods .then, .catch and .finally.

